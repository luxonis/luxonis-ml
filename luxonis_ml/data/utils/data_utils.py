import logging
from collections import defaultdict
from typing import Dict, Iterator, List, Optional, Tuple

import numpy as np
import polars as pl

from luxonis_ml.data.utils.task_utils import task_is_metadata

logger = logging.getLogger(__name__)


def rgb_to_bool_masks(
    segmentation_mask: np.ndarray,
    class_colors: Dict[str, Tuple[int, int, int]],
    add_background_class: bool = False,
) -> Iterator[Tuple[str, np.ndarray]]:
    """Helper function to convert an RGB segmentation mask to boolean
    masks for each class.

    Example:

        >>> segmentation_mask = np.array([
        ...     [[0, 0, 0], [255, 0, 0], [0, 255, 0]],
        ...     [[0, 0, 0], [0, 255, 0], [0, 0, 255]],
        ...     ], dtype=np.uint8)
        >>> class_colors = {
        ...     "red": (255, 0, 0),
        ...     "green": (0, 255, 0),
        ...     "blue": (0, 0, 255),
        ... }
        >>> for class_name, mask in rgb_to_bool_masks(
        ...     segmentation_mask,
        ...     class_colors,
        ...     add_background_class=True,
        ... ):
        ...     print(class_name, np.array2string(mask, separator=", "))
        background [[ True, False, False],
                    [ True, False, False]]
        red        [[False,  True, False],
                    [False, False, False]]
        green      [[False, False,  True],
                    [False, True, False]]
        blue       [[False, False, False],
                    [False, False,  True]]

    @type segmentation_mask: npt.NDArray[np.uint8]
    @param segmentation_mask: An RGB segmentation mask where each pixel
        is colored according to the class it belongs to.
    @type class_colors: Dict[str, Tuple[int, int, int]]
    @param class_colors: A dictionary mapping class names to RGB colors.
    @type add_background_class: bool
    @param add_background_class: Whether to add a background class with a mask for all pixels
        that do not belong to any class. The class name will be set to "background".
        The background class will be yielded first. Default is False.
    @rtype: Iterator[Tuple[str, npt.NDArray[np.bool_]]]
    @return: An iterator of tuples where the first element is the class name and
        the second element is a boolean mask for that class.
    """
    color_to_id = {
        tuple(color): i for i, color in enumerate(class_colors.values())
    }

    lookup_table = np.zeros((256, 256, 256), dtype=np.uint8)
    for color, id in color_to_id.items():
        lookup_table[color[0], color[1], color[2]] = id + 1

    segmentation_ids = lookup_table[
        segmentation_mask[:, :, 0],
        segmentation_mask[:, :, 1],
        segmentation_mask[:, :, 2],
    ]

    if add_background_class:
        background_mask = segmentation_ids == 0
        yield "background", background_mask

    for class_name, color in class_colors.items():
        class_id = color_to_id[tuple(color)] + 1
        yield class_name, segmentation_ids == class_id


def infer_task(
    old_task: str,
    class_name: Optional[str],
    current_classes: Dict[str, List[str]],
) -> str:
    if not hasattr(infer_task, "_logged_infered_classes"):
        infer_task._logged_infered_classes = defaultdict(bool)

    def _log_once(
        cls_: Optional[str], task: str, message: str, level: str = "info"
    ):
        if not infer_task._logged_infered_classes[(cls_, task)]:
            infer_task._logged_infered_classes[(cls_, task)] = True
            getattr(logger, level)(message, extra={"markup": True})

    infered_task = None

    for task, classes in current_classes.items():
        if class_name in classes:
            if infered_task is not None:
                _log_once(
                    class_name,
                    infered_task,
                    f"Class [red italic]{class_name}[reset] is ambiguous between "
                    "tasks [magenta italic]{infered_task}[reset] and [magenta italic]{task}[reset]. "
                    "Task inference failed.",
                    "warning",
                )
                infered_task = None
                break
            infered_task = task
    if infered_task is None:
        _log_once(
            class_name,
            old_task,
            f"Class [red italic]{class_name}[reset] doesn't belong to any existing task. "
            f"Autogenerated task [magenta italic]{old_task}[reset] will be used.",
            "info",
        )
    else:
        _log_once(
            class_name,
            infered_task,
            f"Class [red italic]{class_name}[reset] infered to belong to task [magenta italic]{infered_task}[reset]",
        )
        return infered_task

    return old_task


def warn_on_duplicates(df: pl.LazyFrame) -> None:
    # Warn on duplicate UUIDs
    duplicates_paired = (
        df.group_by("uuid")
        .agg(pl.col("file").n_unique().alias("file_count"))
        .filter(pl.col("file_count") > 1)
        .join(df, on="uuid")
        .select("uuid", "file")
        .unique()
        .group_by("uuid")
        .agg(pl.col("file").alias("files"))
        .filter(pl.col("files").len() > 1)
        .collect()
    )
    for uuid, files in duplicates_paired.iter_rows():
        logger.warning(f"UUID: {uuid} has multiple file names: {files}")

    # Warn on duplicate annotations
    duplicate_annotation = (
        df.group_by(
            "original_filepath",
            "task_name",
            "task_type",
            "annotation",
            "instance_id",
        )
        .agg(pl.len().alias("count"))
        .filter(pl.col("count") > 1)
        .filter(pl.col("annotation") != "{}")
        .drop("instance_id")
    ).collect()

    for (
        file_name,
        task_name,
        task_type,
        annotation,
        count,
    ) in duplicate_annotation.iter_rows():
        if task_type == "segmentation":
            annotation = "<binary mask>"
        if not task_is_metadata(task_type):
            logger.warning(
                f"File '{file_name}' has the same '{task_type}' annotation "
                f"'{annotation}' ({task_name=}) added {count} times."
            )
